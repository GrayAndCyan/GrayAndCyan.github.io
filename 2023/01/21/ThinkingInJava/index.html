<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>Thinking in Java | 樱与抱月</title><meta name="author" content="mizore"><meta name="copyright" content="mizore"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="零散的Java读书笔记与JavaSE基础知识个人积累的集装箱。">
<meta property="og:type" content="article">
<meta property="og:title" content="Thinking in Java">
<meta property="og:url" content="http://example.com/2023/01/21/ThinkingInJava/index.html">
<meta property="og:site_name" content="樱与抱月">
<meta property="og:description" content="零散的Java读书笔记与JavaSE基础知识个人积累的集装箱。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/img/profilePicture.jpg">
<meta property="article:published_time" content="2023-01-21T14:53:47.000Z">
<meta property="article:modified_time" content="2023-10-09T03:39:06.136Z">
<meta property="article:author" content="mizore">
<meta property="article:tag" content="JavaSE">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/img/profilePicture.jpg"><link rel="shortcut icon" href="/img/profilePicture.jpg"><link rel="canonical" href="http://example.com/2023/01/21/ThinkingInJava/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Thinking in Java',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-10-08 19:39:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load',() => { preloader.endLoading() })

  if (false) {
    document.addEventListener('pjax:send', () => { preloader.initLoading() })
    document.addEventListener('pjax:complete', () => { preloader.endLoading() })
  }
})()</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/profilePicture.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://s2.loli.net/2023/01/04/lbGZIwpXcrMNegt.png')"><nav id="nav"><span id="blog-info"><a href="/" title="樱与抱月"><span class="site-name">樱与抱月</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于我</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Thinking in Java</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-21T14:53:47.000Z" title="发表于 2023-01-21 06:53:47">2023-01-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-10-09T03:39:06.136Z" title="更新于 2023-10-08 19:39:06">2023-10-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/">学习</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Thinking in Java"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="Thinking-In-Java"><a href="#Thinking-In-Java" class="headerlink" title="Thinking In Java"></a><em>Thinking In Java</em></h1><hr>


<h2 id="第六章-访问权限控制"><a href="#第六章-访问权限控制" class="headerlink" title="第六章 访问权限控制"></a>第六章 访问权限控制</h2><h3 id="Java访问权限修饰词"><a href="#Java访问权限修饰词" class="headerlink" title="Java访问权限修饰词"></a>Java访问权限修饰词</h3><ul>
<li><p><code>public</code>:接口访问权限，即对其他包中的类仍然公开。包是一个库单元。public实现了客户端程序员得以使用类创建者提供的服务，通过导入类库的方式。</p>
<p>  类创建者：那些创建新数据类型的程序员。<br>  客户端程序员：那些在其应用中使用数据类型的类消费者。</p>
</li>
<li><p><code>default</code>:包访问权限，即当前包中所有类对该成员有访问权限</p>
</li>
<li><p><code>private</code>:类访问权限，该成员只能在它所在类中被访问，其他任何类无法访问它。<br>  因此，<code>private</code>允许你随意改变该成员，而不必考虑这样做是否会影响到包内其他的类。</p>
<p>  任何可以肯定只是该类一个“助手”的方法，都可以把它指定为<code>private</code>，以确保不会在其他包误用到它。</p>
<p>  <code>private</code>可以通过修饰构造器，来控制如何创建对象，如单例模式。</p>
<p>  <code>private</code>在多线程环境下发挥重要作用。</p>
</li>
<li><p><code>protected</code>: 继承访问权限。表示该成员可在派生类、同包类中访问。对，它也提供了包访问权限。</p>
<p>  <code>Cookie</code>类的一个方法<code>bite()</code>被default修饰，<code>ChocolateChip</code>类继承自<code>Cookie</code>类，如果B类在另一个包中，那么B类是无法调用<code>bite()</code>的。若不想让<code>bite()</code>在其他包内被访问的同时，还想要让它在派生类中能被访问，此时可以使用<code>protected</code>修饰<code>bite()</code>。</p>
</li>
</ul>
<h3 id="接口和实现"><a href="#接口和实现" class="headerlink" title="接口和实现"></a>接口和实现</h3><ul>
<li><strong>封装</strong>：把数据和方法包装在类中，以及具体实现的隐藏，常共同被称作封装。</li>
<li>访问权限的控制常被称为是<strong>具体实现的隐藏</strong>。</li>
</ul>
<h3 id="类的访问权限"><a href="#类的访问权限" class="headerlink" title="类的访问权限"></a>类的访问权限</h3><ul>
<li><p>每个编译单元（文件）至多有一个public类，此时文件名与该public类名一致。“至多”也就是说，编译单元也可以不带public类，此时可以对文件随意命名。</p>
</li>
<li><p>类访问权限优先于类成员的访问权限发挥作用。<code>Cookie</code>类如果是包访问权限，那么它的<code>public</code>方法也不能用于其他包的类。由于<code>Cookie</code>类是包访问权限，所以其它包类也不能继承它。即使方法是静态方法，通过<code>import static</code>导入这个方法来用，也是不可以的——编译器会在<code>import static</code>语句<code>Cookie</code>处报错，提示你这样做的前提是<code>Cookie</code>为<code>public</code>。</p>
</li>
</ul>
<br>

<h2 id="第七章-复用类"><a href="#第七章-复用类" class="headerlink" title="第七章  复用类"></a>第七章  复用类</h2><h3 id="组合语法"><a href="#组合语法" class="headerlink" title="组合语法"></a>组合语法</h3><ul>
<li>惰性初始化(Delayed initialization)：在将要使用对象之前才初始化引用。在生成对象不值得以及不必每次都生成对象的情况下，这种方式可以减少额外的负担。如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Delayed initialization</span></span><br><span class="line">        s = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Cookie&#123;&quot;</span> +</span><br><span class="line">            <span class="string">&quot;s=&#x27;&quot;</span> + s + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">            <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="继承语法"><a href="#继承语法" class="headerlink" title="继承语法"></a>继承语法</h3><ul>
<li>为了继承，一般的规则是将所有的数据成员都指定为<code>private</code>，将所有的方法指定为<code>public</code>。派生类不能直接访问基类<code>private</code>成员，但可以通过继承而来的<code>public</code>、<code>protected</code>的方法间接访问。</li>
</ul>
<h4 id="初始化基类"><a href="#初始化基类" class="headerlink" title="初始化基类"></a>初始化基类</h4><ul>
<li>当创建了一个派生类对象时，该对象包含了一个基类对象，这个基类对象被包装在导出类对象内部。</li>
<li>派生类构造器对基类构造器的调用：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Art</span> &#123;</span><br><span class="line">    Art() &#123;System.out.println(<span class="string">&quot;Art constructor&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Drawing</span> <span class="keyword">extends</span> <span class="title class_">Art</span>&#123;</span><br><span class="line">    Drawing(<span class="type">int</span> i) &#123;System.out.println(<span class="string">&quot;Drawing constructor&quot;</span>);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cartoon</span> <span class="keyword">extends</span> <span class="title class_">Drawing</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cartoon</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Cartoon constructor&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Cartoon</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Art constructor</span></span><br><span class="line"><span class="comment">Drawing constructor</span></span><br><span class="line"><span class="comment">Cartoon constructor</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<h3 id="代理语法"><a href="#代理语法" class="headerlink" title="代理语法"></a>代理语法</h3><p>是继承与组合之间的中庸之道，既将一个成员对象置于所要构造的类中（就像组合），又在新类中暴露了该对象的所有方法（就像继承）。下面实例是引入代理类“ <code>SpaceShipDelegation</code> ”处理太空船类与太空船控制模块类两者的依赖关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SpaceShipControls</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span>&#123;&#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpaceShipDelegation</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">SpaceShipControls</span> <span class="variable">spaceShipControls</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SpaceShipControls</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">SpaceShipDelegation</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Delegation methods</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">up</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">        spaceShipControls.up(velocity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">down</span><span class="params">(<span class="type">int</span> velocity)</span> &#123;</span><br><span class="line">        spaceShipControls.down(velocity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">turboBoost</span><span class="params">()</span> &#123;</span><br><span class="line">        spaceShipControls.turboBoost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代理方法可以在Idea中自动生成。</p>
<h3 id="组合与继承的结合使用与选择"><a href="#组合与继承的结合使用与选择" class="headerlink" title="组合与继承的结合使用与选择"></a>组合与继承的结合使用与选择</h3><ul>
<li>无论是在派生类层还是基类层，对方法的重载都可以正常进行。</li>
<li>“is-a”的关系用继承来表达，“has-a”则是用组合来表达。</li>
</ul>
<h3 id="protected关键字"><a href="#protected关键字" class="headerlink" title="protected关键字"></a><code>protected</code>关键字</h3><ul>
<li>用于想要将某些事物尽可能对这个世界隐藏，但仍然允许导出类（也就是派生类）或同包其他类的成员访问它们的情形。</li>
</ul>
<h3 id="向上继承"><a href="#向上继承" class="headerlink" title="向上继承"></a>向上继承</h3><ul>
<li>类继承图：根置于页面的顶端，然后逐渐向下。</li>
<li>向上转型是从一个较专用类型向较通用类型转型，总是安全的。导出类是基类的超集，具备基类所有的方法（但对于基类的<code>private</code>成员，导出类仍是无法访问）。向上转型的过程可能发生的是丢失方法。</li>
<li>自问“是否需要从新类向基类进行向上转型”来判断是用继承还是组合技术。肯定回答对应继承，反之组合。</li>
</ul>
<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a><code>final</code>关键字</h3><p><em>“这是无法改变的。”</em></p>
<ul>
<li>对于基本数据类型，<code>final</code>使数值恒定不变。</li>
<li>当<code>final</code>作用于一个引用时，一旦引用被初始化指向一个对象，就不能把它改为指向另一个对象。但对象自身却是可以被修改的。</li>
<li><code>final</code>修饰方法，使该方法不能在派生类中被重写。在以前还有使用<code>final</code>方法提升效率的考虑，现在相关问题交给编译器和JVM了。现就只有在“禁止重写”情形上对方法使用<code>final</code>。</li>
<li>类中所有的<code>private</code>方法都隐式地指定为是<code>final</code>的。由于派生类无法取用基类的<code>private</code>方法，所以也就无法重写它。重写的一个前提是该方法时基类的接口的一部分，如果方法是<code>private</code>，它就不是基类的接口的一部分，它只是一些隐藏于类中的程序代码。</li>
<li><code>final</code>类不可被继承，它的方法都隐式指定为<code>final</code>的。</li>
</ul>
<h3 id="初始化及类的加载"><a href="#初始化及类的加载" class="headerlink" title="初始化及类的加载"></a>初始化及类的加载</h3><ul>
<li><p>可以说，类是在其派生类被加载时，或其任何<code>static</code>成员被首次访问时加载的。毕竟构造器也是<code>static</code>的，尽管<code>static</code>关键字没有显式地写出来。</p>
</li>
<li><p>类的加载与对象的创建：<br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/12/dbv3fjSVeNXnWUF.png" alt="classhi.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/12/wWczqesEpIDjC1h.png" alt="classload.png"><br><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/12/fdG8Fw127LWavOM.png" alt="objectinit.png"><br>下面这段代码看起来有点冗杂，但我认为还算很好地展示了创建对象的构造器调用规则：</p>
<ol>
<li>递归地向上调用基类构造器。</li>
<li>自上而下地进行类的显式初始化（即按声明顺序进行非默认值的成员的初始化）和执行构造器主体，直到对低层的导出类。</li>
</ol>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TextBook</span>&#123;</span><br><span class="line">    TextBook()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;TextBook()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathTextBook</span> <span class="keyword">extends</span> <span class="title class_">TextBook</span>&#123;</span><br><span class="line">    MathTextBook()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathTextBook()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Knowledge</span>&#123;</span><br><span class="line">    Knowledge()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Knowledge()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MathKnowledge</span> <span class="keyword">extends</span> <span class="title class_">Knowledge</span>&#123;</span><br><span class="line">    MathKnowledge()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathKnowledge()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Knowledge</span> <span class="variable">knowledge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Knowledge</span>();</span><br><span class="line">    People() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;People()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Teacher</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TextBook</span> <span class="variable">textBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TextBook</span>();</span><br><span class="line">    Teacher() &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Teacher()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MathTeacher</span> <span class="keyword">extends</span> <span class="title class_">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Knowledge</span> <span class="variable">mathKnowledge</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathKnowledge</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="type">TextBook</span> <span class="variable">mathTextBook</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MathTextBook</span>();</span><br><span class="line">    MathTeacher()&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;MathTeacher()&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">MathTeacher</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">Knowledge()</span></span><br><span class="line"><span class="comment">People()</span></span><br><span class="line"><span class="comment">TextBook()</span></span><br><span class="line"><span class="comment">Teacher()</span></span><br><span class="line"><span class="comment">Knowledge()</span></span><br><span class="line"><span class="comment">MathKnowledge()</span></span><br><span class="line"><span class="comment">TextBook()</span></span><br><span class="line"><span class="comment">MathTextBook()</span></span><br><span class="line"><span class="comment">MathTeacher()</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<br>

<h2 id="第八章-多态"><a href="#第八章-多态" class="headerlink" title="第八章 多态"></a>第八章 多态</h2><p>  <em>多态也叫做动态绑定、后期绑定或运行时绑定。多态的作用是消除类型之间的耦合关系。</em> </p>
<h3 id="转机"><a href="#转机" class="headerlink" title="转机"></a>转机</h3><ul>
<li>将一个<strong>方法调用</strong>同一个<strong>方法主体</strong>关联起来被称作<strong>绑定</strong>。方法调用就是调用方法的那句代码，如<code>food.consume()</code>，而与之关联的方法主体，是指运行时实际执行的方法体。</li>
<li>多态的含义是：在运行时根据对象的类型进行绑定。支持多态的语言具备这样的机制：编译器一直不知道对象的类型，但该机制能在运行时，通过对象中安置的某种“类型信息”，判断对象的类型，从而找到正确的方法体，从而加以调用。</li>
<li>域、静态方法不具有多态性。由于构造器是隐式的<code>static</code>方法，故构造器也不例外，不具有多态性。</li>
</ul>
<h3 id="用继承进行设计"><a href="#用继承进行设计" class="headerlink" title="用继承进行设计"></a>用继承进行设计</h3><ul>
<li><p><em>用继承表达行为间的差异，并用字段表达状态上的变化（组合）。</em></p>
</li>
<li><p>解决由于使用<strong>向上转型</strong>造成的子类扩充的方法无法被访问的问题，需要用到<strong>向下转型</strong>。</p>
<p>  向下转型不是安全的——圆是一个几何形状，但我们无法知道一个“几何形状”确实是一个圆，它也可以是三角形、正方形。因此需要某种方法确保向下转型的正确性。</p>
<p>  在Java中，所有转型都会在运行时得到检查，进行错误的向下转型会抛出类转型异常<code>ClassCastException</code>。这种在运行时对类型进行检查的行为称作 <strong>“运行时类型识别”（RTTI）</strong> 。此外，RTTI还提供方法，使我们可以在试图向下转型之前，查看所要处理的类型，这便涉及Java的<strong>反射</strong>相关功能。</p>
</li>
</ul>
<br>

<h2 id="第九章-接口"><a href="#第九章-接口" class="headerlink" title="第九章 接口"></a>第九章 接口</h2><h3 id="抽象类和抽象方法"><a href="#抽象类和抽象方法" class="headerlink" title="抽象类和抽象方法"></a>抽象类和抽象方法</h3><ul>
<li>一个类包含抽象方法，那么该类必须被限定为抽象类。不过我们可能会创建一个不含任何抽象方法的抽象类，考虑这种情形：让一个类包含任何<code>abstract</code>方法都显得没有实际意义，但我们也想要阻止产生这个类的任何对象，那么这时把该类作为抽象类便很有意义了。</li>
</ul>
<h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><ul>
<li>接口的域隐式地是<code>static</code>和<code>final</code>的，方法自动是<code>public</code>的，并且方法在被类实现时必须被定义是<code>public</code>的——Java不允许方法在继承过程中被降低了访问权限。</li>
</ul>
<h3 id="完全解耦"><a href="#完全解耦" class="headerlink" title="完全解耦"></a>完全解耦</h3><ul>
<li><p>策略设计模式：创建一个能够根据所传递的参数对象的不同而具有不同行为的方法。</p>
<p>  这类方法包含所要执行的算法中固定不变的部分，而“策略”包含变化的部分。策略就是传递进去的参数对象，不同参数对象表示着不同的策略，策略模式下创建的方法执行着随策略对象的改变而改变的具体行为。</p>
<p>  <a target="_blank" rel="noopener" href="https://www.runoob.com/design-pattern/strategy-pattern.html">菜鸟教程对策略模式的阐述</a></p>
</li>
</ul>
<h3 id="Java中的多重继承"><a href="#Java中的多重继承" class="headerlink" title="Java中的多重继承"></a>Java中的多重继承</h3><ul>
<li>使用接口的核心原因：为了能够向上转型为多个基类型，以及由此带来的灵活性。</li>
<li>使用接口的次要原因：防止客户端程序员创建该类的对象，并确保这仅仅是建立了一个接口。</li>
</ul>
<h3 id="通过继承来扩展接口"><a href="#通过继承来扩展接口" class="headerlink" title="通过继承来扩展接口"></a>通过继承来扩展接口</h3><ul>
<li>接口继承另个接口，可以实现在接口中添加新方法。</li>
<li>值得注意的是，接口继承多个接口，可以实现这多个接口的组合，当然也能在组合后的基础上再增添新方法。但要警惕组合接口时，避免来自不同接口的方法重名——如果返回类型与方法签名都一致，那没关系，这俩方法就是同一方法；如果参数列表不同，那可以，这是重载；但若返回类型不同，方法签名一致，这是错误的，重载是不能仅通过返回类型区分开来的。<br><br>上述所说的“方法签名”，由方法的名称和参数列表组成。</li>
</ul>
<br>

<h2 id="第十章-内部类"><a href="#第十章-内部类" class="headerlink" title="第十章  内部类"></a>第十章  内部类</h2><br>

<h2 id="第十一章-持有对象"><a href="#第十一章-持有对象" class="headerlink" title="第十一章  持有对象"></a>第十一章  持有对象</h2><p><em>实际上是持有对象的引用</em></p>
<ul>
<li><p>Java不能重载操作符，所以对于容器取值，Java需要调方法，比如<code>ArrayList</code>的<code>get()</code>,而不能像C&#x2F;C++只需更为简洁地使用方括号<code>[]</code>即可访问容器持有的对象。</p>
</li>
<li><p>对于常用集合，如<code>ArrayList</code>，看源码我认为是于各方面都必要的。</p>
<p>  <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/15/NhKZAFgSWrJYijq.jpg" alt="1673785738748.jpg"></p>
<p>  事实上，向下转型会发生，是泛型的作用，而不是由于return语句中所写的转型代码，这句代码的转型操作并不会如愿奏效。具体见下文泛型章。</p>
</li>
<li><p>对Java容器类分类：</p>
<ul>
<li><code>Collection</code>：一个独立元素的序列。</li>
<li><code>Map</code>：包含一组组成对的“键值对”对象。称它为映射表、关联数组、字典。</li>
</ul>
</li>
<li><p><code>ArrayList</code>允许使用数字查找值，因此在某种意义上，它将数字与对象关联在了一起，可以发挥上述第二类容器的功能。</p>
</li>
<li><p>迭代器通常被称为轻量级对象，创建它的代价小。</p>
</li>
<li><p>Java的<code>Iterator</code>只能单向移动。</p>
<ul>
<li><code>it.next()</code>:返回迭代器当前位置的下一个元素，并使迭代器移至下一元素位置。</li>
<li><code>it.remove()</code>:删除迭代器当前位置的元素,但更准确的说法是，删除上次调用<code>next()</code>返回的元素——这意味着在调用<code>remove()</code>之前必须先调用<code>next()</code>。</li>
<li>遍历打印并删除集合元素：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;T&gt; it = collection.iterator(); </span><br><span class="line"><span class="keyword">while</span>(it.hasNext()) &#123;</span><br><span class="line">    System.out.println(it.next());</span><br><span class="line">    it.remove();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
迭代器使程序员不必关心容器底层的结构，不必关心容器中元素的数量。</li>
</ul>
</li>
<li><p>任何实现了<code>Iterable</code>接口的类都可以用于<code>foreach</code>语句中，因为该接口包含产生<code>Iterator</code>的<code>iterator()</code>方法，foreach底层是使用了迭代器在序列中移动。<br><code>public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</code><br><code>该代码使所有Collection</code>对象可以使用<code>foreach</code>语句。</p>
</li>
<li><p>简单的容器分类，图源 <em>《Java编程思想》</em> 。<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/16/zCYnSaOX5TgJ7qN.png" alt="简单的容器分类.png"></p>
</li>
</ul>
<br>

<h2 id="第十二章-通过异常处理错误"><a href="#第十二章-通过异常处理错误" class="headerlink" title="第十二章  通过异常处理错误"></a>第十二章  通过异常处理错误</h2><p><em>Java的基本理念是，“ 结构不佳的代码不能运行 ”。</em></p>
<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>Java异常处理的目的在于通过使用较少的代码来简化大型、可靠的程序的生成。此外，它实现了将“描述在正常执行过程中做什么事”的代码和“出了问题怎么办”的代码相分离。异常机制使代码的阅读、编写和调试工作更加井井有条。</li>
</ul>
<h3 id="基本异常"><a href="#基本异常" class="headerlink" title="基本异常"></a>基本异常</h3><ul>
<li><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/19/VqpQJTzj4IdGLxE.png" alt="exception01.png"></li>
</ul>
<h3 id="使用finally继续清理"><a href="#使用finally继续清理" class="headerlink" title="使用finally继续清理"></a>使用<code>finally</code>继续清理</h3><ul>
<li>在<code>return</code>中使用<code>finally</code>，在执行<code>return</code>语句之后，仍可保证重要的清理工作会执行。</li>
</ul>
<br>

<h2 id="第十三章-字符串"><a href="#第十三章-字符串" class="headerlink" title="第十三章  字符串"></a>第十三章  字符串</h2><h3 id="不可变String"><a href="#不可变String" class="headerlink" title="不可变String"></a>不可变String</h3><ul>
<li><code>String</code>类中每一个看起来会修改<code>String</code>值的方法，实际上都是创建了一个全新的修改后内容的<code>String</code>对象。</li>
<li>参数是为该方法提供信息的，而不是想让方法改变自己的。因此，修改参数本身的方法，并不是一个合理的方法。</li>
</ul>
<h3 id="重载-与StringBuilder"><a href="#重载-与StringBuilder" class="headerlink" title="重载+与StringBuilder"></a>重载<code>+</code>与<code>StringBuilder</code></h3><ul>
<li><p>用于字符串拼接操作的<code>+</code>、<code>+=</code>操作符，是Java仅有的两个重载的操作符。明明在Java中，重载操作符相对容易，但Java设计者却以“这很复杂”为由使Java不支持任意重载操作符这一功能。</p>
</li>
<li><p>在使用<code>+</code>、<code>+=</code>进行字符串拼接的语句中，编译器会将创建一个空的<code>StringBuilder</code>对象，调用<code>append()</code>方法进行字符串拼接，最后调用<code>toString()</code>生成<code>String</code>类型的结果。</p>
<p>这一编译器的转换不是很智能——它有个缺陷：如果拼接语句是执行在循环中，那么每一次循环，编译器都会创建一个新的<code>StringBuilder</code>对象，也就是说，循环多少次，就创建了多少个<code>StringBuilder</code>对象。因此，需要循环拼串时，尽可能地避免在循环内部使用<code>+</code>、<code>+=</code>进行字符串拼接，否则我们就容易掉入这个陷阱。</p>
<p>例如，想要把<code>String[]</code>类型的<code>words</code>拼接各元素，连成一个<code>String</code>类型的<code>result</code>，<br>不要这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">    result += word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>建议这样做：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">StringBuffer</span> <span class="variable">resultTemp</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();</span><br><span class="line"><span class="keyword">for</span>(String word : words) &#123;</span><br><span class="line">    resultTemp.append(word);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">String</span> <span class="variable">result</span> <span class="operator">=</span> resultTemp.toString();</span><br></pre></td></tr></table></figure>
</li>
<li><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">特点</th>
</tr>
</thead>
<tbody><tr>
<td align="left">StringBuffer</td>
<td align="left">线程安全，但开销更大。</td>
</tr>
<tr>
<td align="left">StringBuilder</td>
<td align="left">非线程安全，但字符串操作更快。在Java SE5中引入。</td>
</tr>
</tbody></table>
</li>
</ul>
<h3 id="又一个陷阱——无意识的无限递归"><a href="#又一个陷阱——无意识的无限递归" class="headerlink" title="又一个陷阱——无意识的无限递归"></a>又一个陷阱——无意识的无限递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InfiniteRecursion</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;InfiniteRecursion address: &quot;</span> + <span class="built_in">this</span> + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然，该<code>toString()</code>方法想要打印<code>InfiniteRecursion</code>对象的地址，在<code>return</code>语句中，“+”后跟<code>this</code>，会发生自动类型转换——将<code>InfiniteRecursion</code>类型的<code>this</code>转换成<code>String</code>类，如何转换？调用<code>this.toString()</code>。于是，一个无限递归发生了。</p>
<p>修复：使用基类<code>Object</code>的<code>toString()</code>，即将上面<code>this</code>改为<code>super.toString()</code>。</p>
<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><ul>
<li><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/01/19/niew2Dx9agyKsuX.png" alt="正则表达式.png"><br><em>图自<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1Cv411372m?p=124&vd_source=427bf06621d2c6136dd4a9ac4521a3de">b站黑马程序员视频</a></em></p>
</li>
<li><p>示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularExceptionDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;使用正则表达式匹配内容：&quot;</span>);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;详情请进行进一步联系，电话0316-123456789，个人邮箱zxn111@stu.xidian.edu.cn&quot;</span> +</span><br><span class="line">                <span class="string">&quot;电话17745678912，03160721721&quot;</span> +</span><br><span class="line">                <span class="string">&quot;400-100-1234,4001001234&quot;</span>;</span><br><span class="line">        <span class="comment">// 从上面内容获取邮箱与电话号码</span></span><br><span class="line">        <span class="comment">// 定义匹配规则 字符串形式</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">regex</span> <span class="operator">=</span> <span class="string">&quot;(\\w&#123;2,20&#125;@[\\w&amp;&amp;[^_]]&#123;2,20&#125;(\\.[\\w&amp;&amp;[^_]]&#123;2,20&#125;)&#123;1,2&#125;|&quot;</span> +</span><br><span class="line">                <span class="string">&quot;(1[3-9]\\d&#123;9&#125;)|(0\\d&#123;2,6&#125;-?\\d&#123;5,20&#125;)|(400(-?\\d&#123;3,9&#125;)&#123;1,2&#125;))&quot;</span>;</span><br><span class="line">        <span class="comment">// 把上述匹配规则编译成匹配对象</span></span><br><span class="line">        <span class="type">Pattern</span> <span class="variable">pattern</span> <span class="operator">=</span> Pattern.compile(regex);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到一个内容匹配对象</span></span><br><span class="line">        <span class="type">Matcher</span> <span class="variable">matcher</span> <span class="operator">=</span> pattern.matcher(s);</span><br><span class="line">        <span class="comment">// 用matcher这个内容匹配器，按照pattern这个匹配规则，调匹配规则pattern的匹配方法matcher()，去匹配串s中的信息</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始匹配</span></span><br><span class="line">        <span class="keyword">while</span>(matcher.find()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> matcher.group();</span><br><span class="line">            System.out.println(s1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="一些API的使用注意事项"><a href="#一些API的使用注意事项" class="headerlink" title="一些API的使用注意事项"></a>一些API的使用注意事项</h3><ul>
<li><code>String</code>类<code>split()</code>方法：根据匹配给定的正则表达式来拆分字符串。<ul>
<li>注意：<code>.</code> 、 <code>、</code> 、 <code>$</code> 、 <code>| </code> 和 <code>*</code> 等转义字符，必须得前加<code> \\</code> 。</li>
<li>注意：多个分隔符，可以用 <code>|</code> 作为连字符。</li>
</ul>
</li>
</ul>
<br>

<h2 id="第十四章-类型信息"><a href="#第十四章-类型信息" class="headerlink" title="第十四章  类型信息"></a>第十四章  类型信息</h2><br>

<h2 id="第十五章-泛型"><a href="#第十五章-泛型" class="headerlink" title="第十五章  泛型"></a>第十五章  泛型</h2><h3 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h3><ul>
<li>泛型：适用于众多类型。</li>
<li>参数化类型：将类型作为参数。编写类时使用类型参数（用尖括号括住放在类名后），此后使用这个类时用实际的类型替换此类型参数。在创建参数化类型的一个实例时，编译器会负责转型操作，并保证类型的正确性。</li>
<li>Java泛型的核心概念：告诉编译器想使用什么类型，然后编译器帮你处理一切细节。</li>
</ul>
<h3 id="必要性"><a href="#必要性" class="headerlink" title="必要性"></a>必要性</h3><ol>
<li>在需要说明类型的地方一味地使用基类，依赖多态，会造成一定的性能损耗。</li>
<li>拘泥于单继承体系会使程序受限过多——我们希望编写更通用的代码，要使代码能够应用于“某种不具体的类型”，而不是一个具体的接口或类。</li>
</ol>
<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><ul>
<li><p>最初的目的：通过解耦类或方法与使用类型之间的约束，使类或方法具有最广泛的表达能力。</p>
<p>  Java如今的泛型没能做到这一追求，或者说已经不再以之为追求。</p>
</li>
<li><p>用来指定容器要持有什么类型的对象，由编译器保证类型的正确性。</p>
</li>
<li><p>设计元组类库，实现一次方法调用返回多个对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoTuple</span>&lt;A,B&gt;&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> A a;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> B b;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TwoTuple</span><span class="params">(A a, B b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + a + <span class="string">&quot;, &quot;</span>+ b + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ThreeTuple</span>&lt;A,B,C&gt; <span class="keyword">extends</span> <span class="title class_">TwoTuple</span>&lt;A,B&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> C c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ThreeTuple</span><span class="params">(A a, B b, C c)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(a, b);</span><br><span class="line">        <span class="built_in">this</span>.c = c;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;(&quot;</span> + a + <span class="string">&quot;, &quot;</span>+ b + <span class="string">&quot;, &quot;</span> + c + <span class="string">&quot;)&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TupleTest</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> ThreeTuple&lt;String,Integer,Double&gt; <span class="title function_">cnt</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ThreeTuple</span>&lt;&gt;(<span class="string">&quot;Pen&quot;</span>,<span class="number">5</span>,<span class="number">7.99</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(cnt());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">(Pen, 5, 7.99)</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>
<p>在上面代码中，元组类的域在编写上有些特殊：<br>对比 <strong>对域使用<code>private</code>加<code>Getter</code>方法</strong>的写法，这里的<code>public final</code>的写法保证了同样的安全性（<code>final</code>使值不可变），并且更加简洁。</p>
</li>
</ul>
<p>可以使用继承机制实现长度更长的元组。</p>
<p>在《Java编程思想》第四版的第366页，作者展示了使用泛型方法编写的更通用的元组工具类库。</p>
<h3 id="简单泛型"><a href="#简单泛型" class="headerlink" title="简单泛型"></a>简单泛型</h3><ul>
<li>内部类可以访问其外部类的类型参数，如下编写一个传统的下推堆栈，自行实现内部链式存储机制：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LinkedStack</span> &lt;T&gt;&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">        T item;</span><br><span class="line">        Node next;</span><br><span class="line">        Node() &#123;&#125;</span><br><span class="line">        Node(T item, Node next) &#123;</span><br><span class="line">            <span class="built_in">this</span>.item = item;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="title function_">end</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> item == <span class="literal">null</span> &amp;&amp; next == <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Node</span> <span class="variable">top</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(T item)</span>&#123;</span><br><span class="line">        top = <span class="keyword">new</span> <span class="title class_">Node</span>(item,top);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">T</span> <span class="variable">result</span> <span class="operator">=</span> top.item;</span><br><span class="line">        <span class="keyword">if</span>(!top.end()) &#123;</span><br><span class="line">            top = top.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        LinkedStack&lt;String&gt; sk = <span class="keyword">new</span> <span class="title class_">LinkedStack</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(String s : <span class="string">&quot;I am mizore&#x27;s oboe.&quot;</span>.split(<span class="string">&quot; &quot;</span>)) &#123;</span><br><span class="line">            sk.push(s);</span><br><span class="line">        &#125;</span><br><span class="line">        String s;</span><br><span class="line">        <span class="keyword">while</span>((s = sk.pop()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.out.println(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">oboe.</span></span><br><span class="line"><span class="comment">mizore&#x27;s</span></span><br><span class="line"><span class="comment">am</span></span><br><span class="line"><span class="comment">I</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul>
<li>泛型类与非泛型类都可以拥有泛型方法。泛型方法使得该方法能够独立于类而产生变化。</li>
<li><code>static</code>方法如果想使用泛型能力，就必须自己成为泛型方法，因为它无法访问泛型类的类型参数。</li>
<li>类型参数推断：在使用泛型类时，必须在创建对象时指定类型参数的值，如上面代码<code>main()</code>方法中的第一句<code>LinkedStack&lt;String&gt; sk = new LinkedStack&lt;&gt;();</code>，但使用泛型方法时不必指明参数类型，因为编译器会为我们找出具体的类型。这称为<strong>类型参数推断（type argument inference）</strong>。如下面代码所示，普通地调用泛型方法<code>typeJudge()</code>，该方法就像被无限次地重载过：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericMethods</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> <span class="title function_">typeJudge</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        System.out.println(x.getClass().getSimpleName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GenericMethods</span> <span class="variable">gm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GenericMethods</span>();</span><br><span class="line">        gm.typeJudge(<span class="string">&quot;&quot;</span>);</span><br><span class="line">        gm.typeJudge(<span class="number">1</span>);</span><br><span class="line">        gm.typeJudge(<span class="number">1.0</span>);</span><br><span class="line">        gm.typeJudge(<span class="number">1.0f</span>);</span><br><span class="line">        gm.typeJudge(gm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Output:</span></span><br><span class="line"><span class="comment">String</span></span><br><span class="line"><span class="comment">Integer</span></span><br><span class="line"><span class="comment">Double</span></span><br><span class="line"><span class="comment">Float</span></span><br><span class="line"><span class="comment">GenericMethods</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h3 id="擦除的神秘之处与擦除的补偿"><a href="#擦除的神秘之处与擦除的补偿" class="headerlink" title="擦除的神秘之处与擦除的补偿"></a>擦除的神秘之处与擦除的补偿</h3><ul>
<li>在泛型代码内部，无法获得任何有关泛型参数类型的信息。<code>ArrayList&lt;String&gt;</code>与<code>ArrayList&lt;Integer&gt;</code>运行时被视为同一类型。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;().getClass();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;().getClass();</span><br><span class="line">    System.out.println(c1);</span><br><span class="line">    System.out.println(c2);</span><br><span class="line">    System.out.println(c1 == c2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*Output:</span></span><br><span class="line"><span class="comment">class java.util.ArrayList</span></span><br><span class="line"><span class="comment">class java.util.ArrayList</span></span><br><span class="line"><span class="comment">true</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li>
<li>Java泛型的“擦除”设计使泛型类型被替换为它们的非泛型上界（<code>List&lt;T&gt;</code> -&gt; <code>List</code>，<code>T</code> -&gt; <code>Object</code>），是泛型作为Java后引入的特性而需要支持<em>迁移兼容性</em>的一种折中，使泛型以一种较为温和的方式（没有破坏所有现有代码）引入Java，却是导致泛型在Java中作用受限的罪魁祸首。</li>
<li><em>“边界就是发生动作的地方。”</em><br>这里所说的“边界”指对象进入和离开方法的地点。Java泛型的所有动作都由编译器执行，发生在边界处——<strong>对传递进来的值进行额外的编译期检查，并插入对于传递出去的值的转型</strong>。这也就是Java泛型的底层实质了，在不使用泛型情形中无上述动作，是直接储存值与只是取值。</li>
<li>创建类型实例：<code>new T()</code>创建泛型类型实例这一操作无法实现，在Java中。解决方案是传递一个工厂对象来创建实例。（《Java编程思想》第四版P382）</li>
<li>创建泛型数组：仍无法实现。两个方案：<ol>
<li>在任何想要创建泛型数组的地方使用<code>ArrayList</code>。</li>
<li>在集合内部使用<code>Object[]</code>，在使用数组元素时，在容器外部添加对<code>T</code>的转型。（为什么是在外部转型？因为有擦除，容器内部的<code>T</code>成了<code>Object</code>，<code>(T)element</code>是把<code>Object</code>类型的对象“转型”成仍然的<code>Object</code>类型。然而这种无用转型却多次出现在标准类库容器类的源码中。。。我不李姐。。。）</li>
</ol>
</li>
</ul>
<h3 id="边界"><a href="#边界" class="headerlink" title="边界"></a>边界</h3><ul>
<li>边界可以使我们在泛型的参数类型上设置限制条件，强制泛型可以应用的类型，并且可以按照边界类型调用方法，是一定程度上对擦除的抵抗。</li>
<li>Java在此重用了<code>extends</code>关键字进行边界设置，该关键字在此处具有了与以往使用时完全不同的意义。</li>
</ul>
<h3 id="对作者在泛型一章最后所作总结的个人理解"><a href="#对作者在泛型一章最后所作总结的个人理解" class="headerlink" title="对作者在泛型一章最后所作总结的个人理解"></a>对作者在泛型一章最后所作总结的个人理解</h3><p>在使用泛型之前，容器类对于对象的存取会一味使用转型，可能产生“狗在猫列表里”这样的问题，这样的问题只能在运行时发现而非编译阶段，因此，转型很糟糕……吗？不，转型并非糟糕。事实上，“狗在猫列表里”这个问题发生频率很低，即便发生也经不住程序员的测试，难以长久潜伏——它不是一个常见且难以排查的问题。</p>
<p>大家认为，Java的泛型避免了“狗在猫列表里”的错误，实现了类型安全的容器，大获成功，好耶ヽ(✿ﾟ▽ﾟ)ノ！但这是对问题严重程度的高估，也是对Java泛型目前职能的赞扬过度。</p>
<p>泛型的目的在于可表达性，在于编写更通用的“泛化”的代码，而不仅仅是作用于创建类型安全的容器这一方面。Java泛型在创建类型安全的容器方面发挥出色作用，但对于“编写更通用的代码”这一泛型要求，Java泛型需要程序员付出更大的努力与解决更多的问题，才能达到。总之，对于“泛型”二字的真正内涵，Java的泛型特性实在是名高难副。事实就是它有用，但远没有本来设想的那么有用。</p>
<p>Java发布后大约10年才引入泛型，Java设计者最初的这一短见导致了很多棘手的迁移问题与设计缺陷，导致了上述所说的<strong>Java泛型实际发挥出的作用受限</strong>的结果。</p>
<p><br><br></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://s2.loli.net/2023/02/01/dqaUXI4NkC9btvF.jpg" alt="1675247048857.jpg"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://example.com">mizore</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2023/01/21/ThinkingInJava/">http://example.com/2023/01/21/ThinkingInJava/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">樱与抱月</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaSE/">JavaSE</a></div><div class="post_share"><div class="social-share" data-image="/img/profilePicture.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/02/Encapsulation/" title="面向对象的封装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">面向对象的封装</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/15/QingNiao/" title="《青鸟》读书笔记"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">《青鸟》读书笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/02/02/Encapsulation/" title="面向对象的封装"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-01</div><div class="title">面向对象的封装</div></div></a></div><div><a href="/2023/03/30/LambdaAndStream/" title="Lambda表达式与Stream流"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-29</div><div class="title">Lambda表达式与Stream流</div></div></a></div></div></div><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="waline-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/profilePicture.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">mizore</div><div class="author-info__description">Welcome to my blog!!</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">17</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/GrayAndCyan" target="_blank" title=""><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Thinking-In-Java"><span class="toc-number">1.</span> <span class="toc-text">Thinking In Java</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.</span> <span class="toc-text">第六章 访问权限控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E8%AF%8D"><span class="toc-number">1.1.1.</span> <span class="toc-text">Java访问权限修饰词</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">接口和实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90"><span class="toc-number">1.1.3.</span> <span class="toc-text">类的访问权限</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%A4%8D%E7%94%A8%E7%B1%BB"><span class="toc-number">1.2.</span> <span class="toc-text">第七章  复用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.1.</span> <span class="toc-text">组合语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">继承语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%9F%BA%E7%B1%BB"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">初始化基类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%A3%E7%90%86%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">代理语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E4%B8%8E%E7%BB%A7%E6%89%BF%E7%9A%84%E7%BB%93%E5%90%88%E4%BD%BF%E7%94%A8%E4%B8%8E%E9%80%89%E6%8B%A9"><span class="toc-number">1.2.4.</span> <span class="toc-text">组合与继承的结合使用与选择</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#protected%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.5.</span> <span class="toc-text">protected关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E4%B8%8A%E7%BB%A7%E6%89%BF"><span class="toc-number">1.2.6.</span> <span class="toc-text">向上继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.2.7.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%8F%8A%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD"><span class="toc-number">1.2.8.</span> <span class="toc-text">初始化及类的加载</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">第八章 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AC%E6%9C%BA"><span class="toc-number">1.3.1.</span> <span class="toc-text">转机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8%E7%BB%A7%E6%89%BF%E8%BF%9B%E8%A1%8C%E8%AE%BE%E8%AE%A1"><span class="toc-number">1.3.2.</span> <span class="toc-text">用继承进行设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.</span> <span class="toc-text">第九章 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8A%BD%E8%B1%A1%E6%96%B9%E6%B3%95"><span class="toc-number">1.4.1.</span> <span class="toc-text">抽象类和抽象方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.2.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E8%A7%A3%E8%80%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">完全解耦</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java%E4%B8%AD%E7%9A%84%E5%A4%9A%E9%87%8D%E7%BB%A7%E6%89%BF"><span class="toc-number">1.4.4.</span> <span class="toc-text">Java中的多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%BB%A7%E6%89%BF%E6%9D%A5%E6%89%A9%E5%B1%95%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.4.5.</span> <span class="toc-text">通过继承来扩展接口</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E7%AB%A0-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">第十章  内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%8C%81%E6%9C%89%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.6.</span> <span class="toc-text">第十一章  持有对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E9%80%9A%E8%BF%87%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E9%94%99%E8%AF%AF"><span class="toc-number">1.7.</span> <span class="toc-text">第十二章  通过异常处理错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%BC%82%E5%B8%B8"><span class="toc-number">1.7.2.</span> <span class="toc-text">基本异常</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8finally%E7%BB%A7%E7%BB%AD%E6%B8%85%E7%90%86"><span class="toc-number">1.7.3.</span> <span class="toc-text">使用finally继续清理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.8.</span> <span class="toc-text">第十三章  字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8D%E5%8F%AF%E5%8F%98String"><span class="toc-number">1.8.1.</span> <span class="toc-text">不可变String</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%87%8D%E8%BD%BD-%E4%B8%8EStringBuilder"><span class="toc-number">1.8.2.</span> <span class="toc-text">重载+与StringBuilder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%88%E4%B8%80%E4%B8%AA%E9%99%B7%E9%98%B1%E2%80%94%E2%80%94%E6%97%A0%E6%84%8F%E8%AF%86%E7%9A%84%E6%97%A0%E9%99%90%E9%80%92%E5%BD%92"><span class="toc-number">1.8.3.</span> <span class="toc-text">又一个陷阱——无意识的无限递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.8.4.</span> <span class="toc-text">正则表达式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9BAPI%E7%9A%84%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">1.8.5.</span> <span class="toc-text">一些API的使用注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E7%B1%BB%E5%9E%8B%E4%BF%A1%E6%81%AF"><span class="toc-number">1.9.</span> <span class="toc-text">第十四章  类型信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.10.</span> <span class="toc-text">第十五章  泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5-1"><span class="toc-number">1.10.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">1.10.2.</span> <span class="toc-text">必要性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%AE%E7%9A%84"><span class="toc-number">1.10.3.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E5%8D%95%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.10.4.</span> <span class="toc-text">简单泛型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">1.10.5.</span> <span class="toc-text">泛型方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%A6%E9%99%A4%E7%9A%84%E7%A5%9E%E7%A7%98%E4%B9%8B%E5%A4%84%E4%B8%8E%E6%93%A6%E9%99%A4%E7%9A%84%E8%A1%A5%E5%81%BF"><span class="toc-number">1.10.6.</span> <span class="toc-text">擦除的神秘之处与擦除的补偿</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%B9%E7%95%8C"><span class="toc-number">1.10.7.</span> <span class="toc-text">边界</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E4%BD%9C%E8%80%85%E5%9C%A8%E6%B3%9B%E5%9E%8B%E4%B8%80%E7%AB%A0%E6%9C%80%E5%90%8E%E6%89%80%E4%BD%9C%E6%80%BB%E7%BB%93%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3"><span class="toc-number">1.10.8.</span> <span class="toc-text">对作者在泛型一章最后所作总结的个人理解</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/10/Java%E5%90%8E%E7%AB%AF%E9%9D%A2%E7%BB%8F-%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0%E4%B8%AD/" title="Java后端面经-持续更新中">Java后端面经-持续更新中</a><time datetime="2023-10-09T19:49:45.000Z" title="发表于 2023-10-09 11:49:45">2023-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/10/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" title="微服务">微服务</a><time datetime="2023-10-09T19:45:22.000Z" title="发表于 2023-10-09 11:45:22">2023-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/10/10/rabbitmq/" title="RabbitMQ">RabbitMQ</a><time datetime="2023-10-09T19:40:46.000Z" title="发表于 2023-10-09 11:40:46">2023-10-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/08/17/Redis-01/" title="Redis-01">Redis-01</a><time datetime="2023-08-17T06:56:44.000Z" title="发表于 2023-08-16 22:56:44">2023-08-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023/07/11/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C01/" title="计算机网络 Part1">计算机网络 Part1</a><time datetime="2023-07-11T08:37:25.000Z" title="发表于 2023-07-11 00:37:25">2023-07-11</time></div></div></div></div></div></div></main><footer id="footer" style="background: rgba(255,255,255,.0)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By mizore</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><script>function loadWaline () {
  function initWaline () {
    const waline = Waline.init(Object.assign({
      el: '#waline-wrap',
      serverURL: 'https://fragileu-blog.vercel.app/',
      pageview: false,
      dark: 'html[data-theme="dark"]',
      path: window.location.pathname,
      comment: false,
    }, null))
  }

  if (typeof Waline === 'object') initWaline()
  else {
    getCSS('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.css').then(() => {
      getScript('https://cdn.jsdelivr.net/npm/@waline/client/dist/waline.min.js').then(initWaline)
    })
  }
}

if ('Waline' === 'Waline' || !true) {
  if (true) btf.loadComment(document.getElementById('waline-wrap'),loadWaline)
  else setTimeout(loadWaline, 0)
} else {
  function loadOtherComment () {
    loadWaline()
  }
}</script></div><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-show-text.min.js" data-mobile="true" data-text="Honoka,You,Ayumu,Sumire,Megumi" data-fontsize="15px" data-random="true" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>